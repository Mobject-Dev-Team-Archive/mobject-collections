<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="List" Id="{9220d5a8-4969-08a4-1724-7633ca12bf29}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'linkalways'} 
{attribute 'no_explicit_call' := 'This FB is a CLASS and must be accessed using methods or properties'}
{attribute 'enable_dynamic_creation'}
{attribute 'hide_all_locals'}
FUNCTION_BLOCK PUBLIC FINAL List EXTENDS Disposable IMPLEMENTS I_List
VAR
	memoryManager : FB_DynMem_Manager2;
	buffer : FB_DynMem_Buffer(ipMemMan := memoryManager);
	pArray : POINTER TO I_ListNode;
	arrayCapacity : UDINT; //Current capacity of the array
	itemCount : UDINT; //Current items in array
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Constructor" Id="{05571daf-e44d-4345-9c15-aa04afc543d5}" />
    <Folder Name="Destructor" Id="{8fdd593d-4b5b-0cba-142b-2136390a5ba1}" />
    <Folder Name="Private" Id="{f8e6fb94-8042-49e9-832d-ab6b0922fdf1}" />
    <Method Name="AddAt" Id="{4a28931b-7145-4a14-a1cc-726d2ed98557}">
      <Declaration><![CDATA[METHOD AddAt
VAR_INPUT
	Index : UDINT;
	Item : ANY;
END_VAR
VAR
	node : I_ListNode;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Index > Count -1 THEN
	RETURN;
END_IF

node := CreateNewNode(Item);
AddNodeAt(Index, node);]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddFirst" Id="{76c2441e-09ce-4b0a-9ebe-07e27abca2cd}">
      <Declaration><![CDATA[METHOD AddFirst
VAR_INPUT
	Item : ANY;
END_VAR
VAR 
	node : I_ListNode;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[node := CreateNewNode(Item);
AddNodeFirst(node);]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddItem" Id="{4338eac4-cb94-0e48-0359-63eec208e760}">
      <Declaration><![CDATA[METHOD PUBLIC AddItem
VAR_INPUT
	Item : ANY;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[AddLast(Item);]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddLast" Id="{edf5ab2b-eaa8-47f2-bc40-8e873f7c51df}">
      <Declaration><![CDATA[METHOD AddLast
VAR_INPUT
	Item : ANY;
END_VAR
VAR
	node : I_ListNode;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[node := CreateNewNode(Item);
AddNodeLast(node);]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddNodeAt" Id="{434fcbfc-1b21-406c-bc70-53644c6aca95}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE AddNodeAt
VAR_INPUT
	Index : UDINT;
	Node : I_ListNode;
END_VAR
VAR
	i : LINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Index = itemCount THEN
	AddNodeLast(Node);
	RETURN;
END_IF

IF Index > itemCount - 1 THEN
	RETURN;
END_IF

IF Count + 1 > arrayCapacity THEN
	Resize();
END_IF

//Move all excisting nodes up
FOR i := itemCount - 1 TO Index BY -1 DO
	pArray[i + 1] := pArray[i];
	pArray[i] := 0;
END_FOR

pArray[Index] := Node;
itemCount := itemCount + 1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddNodeFirst" Id="{cc972e35-be17-402a-9d4f-271e4c0ebf2e}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE AddNodeFirst
VAR_INPUT
	Node : I_ListNode;
END_VAR
VAR
	i : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[AddNodeAt(0, Node);]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddNodeLast" Id="{0fd32a56-42dd-46f2-9f6e-72084c72716b}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE AddNodeLast
VAR_INPUT
	Node : I_ListNode;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Count = arrayCapacity THEN
    Resize();
END_IF

pArray[itemCount] := Node;
itemCount := itemCount + 1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Clear" Id="{6a51ab3d-5d81-406b-91df-b56045948387}">
      <Declaration><![CDATA[METHOD Clear
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[buffer.Clear();
itemCount := 0;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Contains" Id="{8d070616-89e9-48db-8902-c17e7098b90d}">
      <Declaration><![CDATA[METHOD Contains : BOOL
VAR_INPUT
	Item : ANY;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF itemCount < 1 THEN
	RETURN;
END_IF

Contains := TryGetIndexOf(Item);]]></ST>
      </Implementation>
    </Method>
    <Method Name="CopyTo" Id="{08647dfb-c5bf-4481-b560-e5f349a8a87f}">
      <Declaration><![CDATA[METHOD PUBLIC CopyTo : BOOL
VAR_INPUT
	Destination	: ANY;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CopyTo := CopyToLocation(Destination.pValue, DINT_TO_UDINT(Destination.diSize));]]></ST>
      </Implementation>
    </Method>
    <Method Name="CopyToLocation" Id="{2460292a-feaa-4f20-a5c3-9f55d0dc2c6c}">
      <Declaration><![CDATA[METHOD PUBLIC CopyToLocation : BOOL
VAR_INPUT
	Destination : PVOID;
	DestinationSize : UDINT;
END_VAR
VAR
	i : ULINT;
	requiredSize : UDINT;
	current : I_ListNode;
	pCurrent : PVOID;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Count = 0 THEN
    RETURN;
END_IF

//Compute required size
FOR i := 0 TO Count - 1 DO
    current := GetNodeByIndex(i);
    requiredSize := requiredSize + current.DataSize;
END_FOR

//If destination size is to small abort
IF DestinationSize < requiredSize THEN
    RETURN;
END_IF

pCurrent := Destination;

FOR i := 0 TO Count - 1 DO
    current := GetNodeByIndex(i);
    current.TryGetTo(pCurrent, current.DataSize);
    pCurrent := pCurrent + current.DataSize;
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Property Name="Count" Id="{18af26e5-6368-08f4-3269-b1e13029edb8}">
      <Declaration><![CDATA[PROPERTY PUBLIC Count : ULINT]]></Declaration>
      <Get Name="Get" Id="{84d29658-765a-06de-2dbc-7bd104ca837e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Count := itemCount;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="CreateNewNode" Id="{669eec89-9d9f-4b2d-8f7d-4af8a72f842c}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE CreateNewNode : I_ListNode
VAR_INPUT
	Value : ANY;
END_VAR
VAR
	pNode : POINTER TO ListNode;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[pNode := __NEW(ListNode);
pNode^.Initialize(Value);
CreateNewNode := pNode^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_exit" Id="{a189a9f3-674e-0a1c-24b3-a20087e08971}" FolderPath="Destructor\">
      <Declaration><![CDATA[METHOD FB_exit : BOOL
VAR_INPUT
	bInCopyCode : BOOL; // if TRUE, the exit method is called for exiting an instance that is copied afterwards (online change).
END_VAR
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF bInCopyCode THEN
    RETURN;
END_IF

buffer.DeleteBuffer();
pArray := 0;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{8ec4533e-a5dc-4e2a-96e9-2d084d50f0e0}" FolderPath="Constructor\">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	InitialCapacity : UDINT;
END_VAR
VAR
	node : I_ListNode;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[buffer.CreateBuffer(nSize := InitialCapacity * SIZEOF(node), bReset := TRUE);
pArray := buffer.pBuffer;
arrayCapacity := InitialCapacity;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetByIndex" Id="{cc839167-9497-078f-3a33-ea3196df2fb9}">
      <Declaration><![CDATA[METHOD PUBLIC GetByIndex : BOOL
VAR_INPUT
	Index : UDINT;
	Destination : ANY;
END_VAR
VAR
	node : I_ListNode;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsEmpty() THEN
	RETURN;
END_IF

node := GetNodeByIndex(Index);

IF node = 0 THEN
	RETURN;
END_IF

node.TryGet(Destination);
GetByIndex := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetEnumerator" Id="{fea1fcad-e669-422d-9653-a618518cd1c8}">
      <Declaration><![CDATA[METHOD GetEnumerator : I_ForwardEnumerator
VAR
	pEnumerator : POINTER TO ListForwardEnumerator;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pEnumerator := __NEW(ListForwardEnumerator(List := THIS^));
GetEnumerator := pEnumerator^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetNodeByIndex" Id="{5f4268ee-abf7-400e-939d-8a03550a5e63}">
      <Declaration><![CDATA[METHOD PUBLIC GetNodeByIndex : I_ListNode
VAR_INPUT
	Index : ULINT;
END_VAR
VAR
	pCurrent : I_ListNode;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Index < itemCount AND Index >= 0 THEN
	pCurrent := pArray[Index];
	GetNodeByIndex := pCurrent;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetToByIndex" Id="{214e3e6b-3dc2-46e0-ab4f-539af069b26d}">
      <Declaration><![CDATA[METHOD GetToByIndex : BOOL
VAR_INPUT
	Index	: UDINT;
	Destination	: PVOID;
	DestinationSize	: UDINT;
END_VAR
VAR
	node : I_ListNode;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsEmpty() THEN
	RETURN;
END_IF

node := GetNodeByIndex(Index);

IF node = 0 THEN
	RETURN;
END_IF

GetToByIndex := node.TryGetTo(Destination, DestinationSize);]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsEmpty" Id="{c3ebfab7-6e9b-4a26-b4d6-f2fc75649597}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE IsEmpty : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IsEmpty := itemCount = 0;]]></ST>
      </Implementation>
    </Method>
    <Method Name="RemoveAt" Id="{5fddda2d-2bc3-08a7-1fc5-3303b29b003f}">
      <Declaration><![CDATA[METHOD PUBLIC RemoveAt : BOOL;
VAR_INPUT
	Index : UDINT;
END_VAR
VAR
	i : UDINT;
	node : I_ListNode;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Index < 0 OR Index >= itemCount THEN
	RETURN;
END_IF

node := GetNodeByIndex(Index);
node.Dispose();

FOR i := Index + 1 TO itemCount - 1 DO
	pArray[i - 1] := pArray[i];
	pArray[i] := 0;
END_FOR

itemCount := itemCount - 1;
RemoveAt := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="RemoveItem" Id="{405b8587-bb35-4a7f-9adc-3766cc05ff19}">
      <Declaration><![CDATA[METHOD RemoveItem : BOOL
VAR_INPUT
    Item : ANY;
END_VAR
VAR
    result : BOOL;
    index : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[result := TryGetIndexOf(item := Item, index => index);

IF NOT result THEN
	RETURN;
END_IF

RemoveItem := RemoveAt(index);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Resize" Id="{aa524b81-d1fc-4fc5-8e9b-5c5798157c90}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE Resize
VAR_INPUT
END_VAR
VAR
	node : I_ListNode;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[arrayCapacity := arrayCapacity * 2;
buffer.Resize(nSize := arrayCapacity * SIZEOF(node), bPreserve := TRUE, bReset := FALSE);
pArray := buffer.pBuffer;]]></ST>
      </Implementation>
    </Method>
    <Method Name="TryGetIndexOf" Id="{11432220-b6bf-4ad5-94bd-7b00101eef0a}">
      <Declaration><![CDATA[//Try to get the first index of a item
//Returns true is the collectable is found.
METHOD PUBLIC TryGetIndexOf : BOOL
VAR_INPUT
	Item : ANY;
END_VAR
VAR_OUTPUT
	Index : UDINT;
END_VAR
VAR
	node : I_ListNode;
	i : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF itemCount < 1 THEN
	RETURN;
END_IF

FOR i := 0 TO itemCount - 1 DO
	node := GetNodeByIndex(i);
	
	IF node.Equals(Item) THEN
		Index := i;
		TryGetIndexOf := TRUE;
		RETURN;
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>